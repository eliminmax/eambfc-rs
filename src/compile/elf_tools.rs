// SPDX-FileCopyrightText: 2024 - 2025 Eli Array Minkoff
//
// SPDX-License-Identifier: GPL-3.0-only

#[derive(Debug, Clone, Copy, PartialEq)]
enum ElfClass {
    ELFClass64 = 2,
}

impl ElfClass {
    const fn ehdr_sz(self) -> u16 {
        match self {
            ElfClass::ELFClass64 => 64,
        }
    }
    const fn phdr_sz(self) -> u16 {
        match self {
            ElfClass::ELFClass64 => 56,
        }
    }
}

#[derive(Clone, Copy)]
pub(super) enum ByteOrdering {
    #[cfg(any(feature = "x86_64", feature = "riscv64", feature = "arm64"))]
    LittleEndian = 1,
    #[cfg(feature = "s390x")]
    BigEndian = 2,
}

/// Enum of supported backends
#[derive(Debug, Clone, Copy, PartialEq)]
pub(crate) enum Backend {
    #[cfg(feature = "arm64")]
    Arm64,
    #[cfg(feature = "riscv64")]
    RiscV64,
    #[cfg(feature = "s390x")]
    S390x,
    #[cfg(feature = "x86_64")]
    X86_64,
}

impl Backend {
    /// Get the `e_machine` value for the architecture
    const fn e_machine(self) -> u16 {
        match self {
            #[cfg(feature = "arm64")]
            Self::Arm64 => 183,
            #[cfg(feature = "riscv64")]
            Self::RiscV64 => 243,
            #[cfg(feature = "s390x")]
            Self::S390x => 22,
            #[cfg(feature = "x86_64")]
            Self::X86_64 => 62,
        }
    }
    /// Get the `ElfClass` for the architecture
    #[expect(
        clippy::unused_self,
        reason = "Once 32-bit architectures are used, won't be unused"
    )]
    const fn ei_class(self) -> ElfClass {
        ElfClass::ELFClass64
    }

    /// Get the `ByteOrdering` for the architecture
    pub(super) const fn ei_data(self) -> ByteOrdering {
        match self {
            #[cfg(feature = "s390x")]
            Self::S390x => ByteOrdering::BigEndian,
            #[cfg(any(feature = "x86_64", feature = "riscv64", feature = "arm64"))]
            _ => ByteOrdering::LittleEndian,
        }
    }
}

impl std::fmt::Display for Backend {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> Result<(), std::fmt::Error> {
        write!(
            f,
            "{}",
            match *self {
                #[cfg(feature = "arm64")]
                Backend::Arm64 => "arm64",
                #[cfg(feature = "riscv64")]
                Backend::RiscV64 => "riscv64",
                #[cfg(feature = "s390x")]
                Backend::S390x => "s390x",
                #[cfg(feature = "x86_64")]
                Backend::X86_64 => "x86_64",
            }
        )
    }
}

impl Default for Backend {
    fn default() -> Self {
        match env!("EAMBFC_DEFAULT_ARCH") {
            #[cfg(feature = "arm64")]
            "arm64" => Backend::Arm64,
            #[cfg(feature = "riscv64")]
            "riscv64" => Backend::RiscV64,
            #[cfg(feature = "s390x")]
            "s390x" => Backend::S390x,
            #[cfg(feature = "x86_64")]
            "x86_64" => Backend::X86_64,
            _ => unreachable!("build.rs sets this to valid values only"),
        }
    }
}

impl From<Backend> for [u8; 16] {
    fn from(e_arch: Backend) -> [u8; 16] {
        #[rustfmt::skip]
        let arr: [u8; 16] = [
            // magic bytes
            0x7f, b'E', b'L', b'F',
            // 32 or 64 bit
            e_arch.ei_class() as u8,
            // byte ordering for architecture
            e_arch.ei_data() as u8,
            // Version of an ELF file - only valid value
            1,
            // SYSV ABI with unspecified version
            0, 0,
            // padding bytes
            0, 0, 0, 0, 0, 0, 0
        ];
        arr
    }
}

/// The information needed to construct an ELF Ehdr, not including information which is always the
/// same across all ELF executables generated by `eambfc-rs`
pub(super) struct BinInfo {
    /// The target backend - used to determine the pointer size, byte ordering, and `e_machine`
    /// value for the Ehdr
    pub arch: Backend,
    pub entry: u64,
    pub flags: u32,
}

pub(super) struct Phdr {
    pub arch: Backend,
    pub flags: u32,
    pub offset: u64,
    pub vaddr: u64,
    pub filesz: u64,
    pub memsz: u64,
    pub align: u64,
}

macro_rules! serialize_ehdr {
    ($item: ident, $func: ident, $addr_type: ty) => {{
        let mut v = Vec::with_capacity($item.arch.ei_class().ehdr_sz().into());
        v.extend(<[u8; 16]>::from($item.arch));
        // e_type = ET_EXEC
        v.extend(u16::$func(2));
        // e_machine depends on architecture
        v.extend($item.arch.e_machine().$func());
        // e_version = 1
        v.extend(u32::$func(1));
        // e_entry
        v.extend(
            <$addr_type>::try_from($item.entry)
                .expect("Validated tape size")
                .$func(),
        );
        // e_phoff is always equal to e_ehsize, which depends on the architecture class
        v.extend(<$addr_type>::from($item.arch.ei_class().ehdr_sz()).$func());
        // e_shoff is always zero
        v.extend(<$addr_type>::$func(0));
        // e_flags depends on the architecture and is specified in the backend
        v.extend($item.flags.$func());
        // e_ehsize depends on the architecture class
        v.extend($item.arch.ei_class().ehdr_sz().$func());
        // e_phentsize depends on the architecture class
        v.extend($item.arch.ei_class().phdr_sz().$func());
        // e_phnum is always 2: 1 for the code segment and 1 for the tape segment
        v.extend(u16::$func(2));
        // e_shentsize is zero as there is no section header table
        v.extend(u16::$func(0));
        // e_shnum is zero as there is no section header table
        v.extend(u16::$func(0));
        // e_shstrndx is zero as there is no section header table
        v.extend(u16::$func(0));
        v
    }};
}
// better this than having identical implementations, differing only in whether to_le_bytes or
// to_be_bytes are called.
macro_rules! serialize_ehdr64 {
    ($item:ident, $func:ident) => {{ serialize_ehdr!($item, $func, u64) }};
}

macro_rules! serialize_phdr64 {
    ($item:ident, $func:ident) => {{
        let mut v = Vec::with_capacity(56);
        v.extend(u32::$func(1));
        v.extend($item.flags.$func());
        v.extend($item.offset.$func());
        v.extend($item.vaddr.$func());
        v.extend(u64::$func(0));
        v.extend($item.filesz.$func());
        v.extend($item.memsz.$func());
        v.extend($item.align.$func());
        v
    }};
}

impl From<BinInfo> for Vec<u8> {
    fn from(item: BinInfo) -> Self {
        match item.arch.ei_data() {
            #[cfg(any(feature = "arm64", feature = "riscv64", feature = "x86_64"))]
            ByteOrdering::LittleEndian => serialize_ehdr64!(item, to_le_bytes),
            #[cfg(feature = "s390x")]
            ByteOrdering::BigEndian => serialize_ehdr64!(item, to_be_bytes),
        }
    }
}

// as endian-ness is not communicated in Phdr entries, it's added to the Phdr struct used within
// eambfc-rs for this.
impl From<Phdr> for Vec<u8> {
    fn from(item: Phdr) -> Self {
        match item.arch.ei_data() {
            #[cfg(any(feature = "arm64", feature = "riscv64", feature = "x86_64"))]
            ByteOrdering::LittleEndian => serialize_phdr64!(item, to_le_bytes),
            #[cfg(feature = "s390x")]
            ByteOrdering::BigEndian => serialize_phdr64!(item, to_be_bytes),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::Backend;
    #[test]
    fn display_elfarch() {
        #[cfg(feature = "arm64")]
        assert_eq!(format!("{}", Backend::Arm64), String::from("arm64"));
        #[cfg(feature = "riscv64")]
        assert_eq!(format!("{}", Backend::RiscV64), String::from("riscv64"));
        #[cfg(feature = "s390x")]
        assert_eq!(format!("{}", Backend::S390x), String::from("s390x"));
        #[cfg(feature = "x86_64")]
        assert_eq!(format!("{}", Backend::X86_64), String::from("x86_64"));
    }
}
